name: Release Please

on:
  push:
    branches:
      - dev
      - main

permissions:
  contents: write
  pull-requests: write

jobs:
  release-please:
    runs-on: ubuntu-latest
    outputs:
      simba_released: ${{ steps.release_dev.outputs.release_created || steps.release_main.outputs.release_created }}
      simba_tag: ${{ steps.release_dev.outputs.tag_name || steps.release_main.outputs.tag_name }}
      websocket_released: ${{ steps.release_dev.outputs['websocket--release_created'] || steps.release_main.outputs['websocket--release_created'] }}
      websocket_tag: ${{ steps.release_dev.outputs['websocket--tag_name'] || steps.release_main.outputs['websocket--tag_name'] }}
      telemetry_released: ${{ steps.release_dev.outputs['telemetry--release_created'] || steps.release_main.outputs['telemetry--release_created'] }}
      telemetry_tag: ${{ steps.release_dev.outputs['telemetry--tag_name'] || steps.release_main.outputs['telemetry--tag_name'] }}
    steps:
      - name: Run Release Please (dev)
        if: github.ref_name == 'dev'
        id: release_dev
        uses: googleapis/release-please-action@v4
        with:
          target-branch: dev
          config-file: release-please-config.dev.json
          manifest-file: .release-please-manifest.dev.json

      - name: Run Release Please (main)
        if: github.ref_name == 'main'
        id: release_main
        uses: googleapis/release-please-action@v4
        with:
          target-branch: main
          config-file: release-please-config.json
          manifest-file: .release-please-manifest.json

  # Sync all module versions to match the root simba version.
  # Release-please only bumps packages that have relevant commits, so this
  # job force-updates the manifest, tags, and creates releases for any module
  # that was left behind.
  sync-versions:
    needs: release-please
    if: >-
      always() &&
      !failure() &&
      (needs.release-please.outputs.simba_released == 'true')
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.ref_name }}
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Go
        uses: actions/setup-go@v4
        with:
          go-version: "1.25"

      - name: Sync versions and update dependencies
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          REPO_URL="https://x-access-token:${GITHUB_TOKEN}@github.com/${{ github.repository }}.git"
          BRANCH="${{ github.ref_name }}"
          ROOT_TAG="${{ needs.release-please.outputs.simba_tag }}"
          # Strip the leading 'v' to get the bare version (e.g. "0.31.0-dev.1")
          TARGET_VERSION="${ROOT_TAG#v}"

          if [ "$BRANCH" = "dev" ]; then
            MANIFEST=".release-please-manifest.dev.json"
          else
            MANIFEST=".release-please-manifest.json"
          fi

          git config user.email "actions@github.com"
          git config user.name "github-actions[bot]"

          MODULES="websocket telemetry"

          for MODULE in $MODULES; do
            CURRENT=$(jq -r ".\"$MODULE\"" "$MANIFEST")
            echo "$MODULE: current=$CURRENT target=$TARGET_VERSION"

            # Update manifest entry if it doesn't already match
            if [ "$CURRENT" != "$TARGET_VERSION" ]; then
              jq -r ".\"$MODULE\" = \"$TARGET_VERSION\"" "$MANIFEST" > "$MANIFEST.tmp"
              mv "$MANIFEST.tmp" "$MANIFEST"
            fi

            # Always update the go.mod dependency on the root module
            cd "$MODULE"
            go mod edit -require="github.com/${{ github.repository }}@$ROOT_TAG"
            go mod tidy || (echo "Retrying go mod tidy..." && sleep 5 && go mod tidy)
            cd ..
          done

          # Commit everything together if anything changed
          git add "$MANIFEST" websocket/go.mod websocket/go.sum telemetry/go.mod telemetry/go.sum || true
          if ! git diff --staged --quiet; then
            git commit -m "chore: sync all modules to $ROOT_TAG"
            git push "$REPO_URL" "HEAD:refs/heads/$BRANCH"
          fi

          # Tag and release any module that was behind
          for MODULE in $MODULES; do
            MODULE_TAG="${MODULE}/v${TARGET_VERSION}"

            # Skip if tag already exists (release-please already released this module)
            if git rev-parse --verify "refs/tags/$MODULE_TAG" >/dev/null 2>&1; then
              echo "$MODULE already tagged at $MODULE_TAG, skipping"
              continue
            fi

            git tag -a "$MODULE_TAG" -m "Release $MODULE_TAG" HEAD
            git push "$REPO_URL" "refs/tags/$MODULE_TAG"
            echo "Tagged and pushed $MODULE_TAG"

            # Store which modules need a GitHub release created
            echo "$MODULE" >> /tmp/modules_to_release
          done

      - name: Create GitHub releases for synced modules
        if: always()
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          if [ ! -f /tmp/modules_to_release ]; then
            echo "No modules need a GitHub release"
            exit 0
          fi

          ROOT_TAG="${{ needs.release-please.outputs.simba_tag }}"
          TARGET_VERSION="${ROOT_TAG#v}"
          PRERELEASE="false"
          if [ "${{ github.ref_name }}" = "dev" ]; then
            PRERELEASE="true"
          fi

          while read -r MODULE; do
            MODULE_TAG="${MODULE}/v${TARGET_VERSION}"
            echo "Creating release for $MODULE_TAG"
            gh release create "$MODULE_TAG" \
              --title "$MODULE_TAG" \
              --body "Synchronized with root simba release $ROOT_TAG" \
              --prerelease="$PRERELEASE" \
              --repo "${{ github.repository }}"
          done < /tmp/modules_to_release
